"use strict";
const require_binding = require('../shared/binding-orkvONpS.cjs');

//#region src/parse-ast-index.ts
function wrap(result, sourceText) {
	let program, module$1, comments, errors, magicString;
	return {
		get program() {
			if (!errors) errors = result.errors;
			if (errors.length > 0) return normalizeParseError(sourceText, errors);
			if (!program) program = JSON.parse(result.program);
			return program;
		},
		get module() {
			if (!module$1) module$1 = result.module;
			return module$1;
		},
		get comments() {
			if (!comments) comments = result.comments;
			return comments;
		},
		get errors() {
			if (!errors) errors = result.errors;
			return errors;
		},
		get magicString() {
			if (!magicString) magicString = result.magicString;
			return magicString;
		}
	};
}
function normalizeParseError(sourceText, errors) {
	let message = `Parse failed with ${errors.length} error${errors.length < 2 ? "" : "s"}:\n`;
	for (let i = 0; i < errors.length; i++) {
		if (i >= 5) {
			message += "\n...";
			break;
		}
		const e = errors[i];
		message += e.message + "\n" + e.labels.map((label) => {
			const location = require_binding.locate(sourceText, label.start, { offsetLine: 1 });
			if (!location) return;
			return require_binding.getCodeFrame(sourceText, location.line, location.column);
		}).filter(Boolean).join("\n");
	}
	return require_binding.error(require_binding.logParseError(message));
}
function parseAst(filename, sourceText, options) {
	return wrap((0, require_binding.import_binding.parseSync)(filename, sourceText, options), sourceText);
}
async function parseAstAsync(filename, sourceText, options) {
	return wrap(await (0, require_binding.import_binding.parseAsync)(filename, sourceText, options), sourceText);
}

//#endregion
exports.parseAst = parseAst
exports.parseAstAsync = parseAstAsync