import { transformToRollupOutput } from '../../utils/transform-to-rollup-output';
import { createBundler, } from '../../utils/create-bundler';
// @ts-expect-error TS2540: the polyfill of `asyncDispose`.
Symbol.asyncDispose ??= Symbol('Symbol.asyncDispose');
export class RolldownBuild {
    #inputOptions;
    #bundler;
    constructor(inputOptions) {
        // TODO: Check if `inputOptions.output` is set. If so, throw an warning that it is ignored.
        this.#inputOptions = inputOptions;
    }
    get closed() {
        // If the bundler has not yet been created, it is not closed.
        return this.#bundler ? this.#bundler.bundler.closed : false;
    }
    // Create bundler for each `bundle.write/generate`
    async #getBundlerWithStopWorker(outputOptions) {
        if (this.#bundler) {
            this.#bundler.stopWorkers?.();
        }
        return (this.#bundler = await createBundler(this.#inputOptions, outputOptions));
    }
    async generate(outputOptions = {}) {
        const { bundler } = await this.#getBundlerWithStopWorker(outputOptions);
        const output = await bundler.generate();
        return transformToRollupOutput(output);
    }
    async write(outputOptions = {}) {
        const { bundler } = await this.#getBundlerWithStopWorker(outputOptions);
        const output = await bundler.write();
        return transformToRollupOutput(output);
    }
    async close() {
        const { bundler, stopWorkers } = await this.#getBundlerWithStopWorker({});
        await stopWorkers?.();
        await bundler.close();
    }
    async [Symbol.asyncDispose]() {
        await this.close();
    }
}
function _assert() {
}
