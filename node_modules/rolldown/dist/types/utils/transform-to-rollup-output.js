import { bindingAssetSource, transformAssetSource, } from './asset-source';
import { bindingifySourcemap } from '../types/sourcemap';
import { normalizeErrors } from './error';
import { transformChunkModules } from './transform-rendered-chunk';
import { Buffer } from 'node:buffer';
function transformToRollupSourceMap(map) {
    const parsed = JSON.parse(map);
    const obj = {
        ...parsed,
        toString() {
            return JSON.stringify(obj);
        },
        toUrl() {
            return `data:application/json;charset=utf-8;base64,${Buffer.from(obj.toString(), 'utf-8').toString('base64')}`;
        },
    };
    return obj;
}
function transformToRollupOutputChunk(bindingChunk, changed) {
    const chunk = {
        type: 'chunk',
        get code() {
            return bindingChunk.code;
        },
        fileName: bindingChunk.fileName,
        name: bindingChunk.name,
        get modules() {
            return transformChunkModules(bindingChunk.modules);
        },
        get imports() {
            return bindingChunk.imports;
        },
        get dynamicImports() {
            return bindingChunk.dynamicImports;
        },
        exports: bindingChunk.exports,
        isEntry: bindingChunk.isEntry,
        facadeModuleId: bindingChunk.facadeModuleId || null,
        isDynamicEntry: bindingChunk.isDynamicEntry,
        get moduleIds() {
            return bindingChunk.moduleIds;
        },
        get map() {
            return bindingChunk.map
                ? transformToRollupSourceMap(bindingChunk.map)
                : null;
        },
        sourcemapFileName: bindingChunk.sourcemapFileName || null,
        preliminaryFileName: bindingChunk.preliminaryFileName,
    };
    const cache = {};
    return new Proxy(chunk, {
        get(target, p) {
            if (p in cache) {
                return cache[p];
            }
            return target[p];
        },
        set(target, p, newValue) {
            cache[p] = newValue;
            changed?.updated.add(bindingChunk.fileName);
            return true;
        },
    });
}
function transformToRollupOutputAsset(bindingAsset, changed) {
    const asset = {
        type: 'asset',
        fileName: bindingAsset.fileName,
        originalFileName: bindingAsset.originalFileName || null,
        originalFileNames: bindingAsset.originalFileNames,
        get source() {
            return transformAssetSource(bindingAsset.source);
        },
        name: bindingAsset.name ?? undefined,
        names: bindingAsset.names,
    };
    const cache = {};
    return new Proxy(asset, {
        get(target, p) {
            if (p in cache) {
                return cache[p];
            }
            return target[p];
        },
        set(target, p, newValue) {
            cache[p] = newValue;
            changed?.updated.add(bindingAsset.fileName);
            return true;
        },
    });
}
export function transformToRollupOutput(output, changed) {
    handleOutputErrors(output);
    const { chunks, assets } = output;
    return {
        output: [
            ...chunks.map((chunk) => transformToRollupOutputChunk(chunk, changed)),
            ...assets.map((asset) => transformToRollupOutputAsset(asset, changed)),
        ],
    };
}
export function handleOutputErrors(output) {
    const rawErrors = output.errors;
    if (rawErrors.length > 0) {
        throw normalizeErrors(rawErrors);
    }
}
export function transformToOutputBundle(output, changed) {
    const bundle = Object.fromEntries(transformToRollupOutput(output, changed).output.map((item) => [
        item.fileName,
        item,
    ]));
    return new Proxy(bundle, {
        deleteProperty(target, property) {
            if (typeof property === 'string') {
                changed.deleted.add(property);
            }
            return true;
        },
    });
}
// TODO find a way only transfer the changed part to rust side.
export function collectChangedBundle(changed, bundle) {
    const assets = [];
    const chunks = [];
    for (const key in bundle) {
        if (changed.deleted.has(key) || !changed.updated.has(key)) {
            continue;
        }
        const item = bundle[key];
        if (item.type === 'asset') {
            assets.push({
                filename: item.fileName,
                originalFileNames: item.originalFileNames,
                source: bindingAssetSource(item.source),
                names: item.names,
            });
        }
        else {
            // not all properties modifications are reflected to rust side
            chunks.push({
                code: item.code,
                filename: item.fileName,
                name: item.name,
                isEntry: item.isEntry,
                exports: item.exports,
                modules: {},
                imports: item.imports,
                dynamicImports: item.dynamicImports,
                facadeModuleId: item.facadeModuleId || undefined,
                isDynamicEntry: item.isDynamicEntry,
                moduleIds: item.moduleIds,
                map: bindingifySourcemap(item.map),
                sourcemapFilename: item.sourcemapFileName || undefined,
                preliminaryFilename: item.preliminaryFileName,
            });
        }
    }
    return {
        assets,
        chunks,
        deleted: Array.from(changed.deleted),
    };
}
