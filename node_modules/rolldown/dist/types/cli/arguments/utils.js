const priority = [
    'object',
    'array',
    'string',
    'number',
    'boolean',
];
export function getSchemaType(schema) {
    if ('anyOf' in schema) {
        const types = schema.anyOf.map(getSchemaType);
        // Order: object > array > string > number > boolean
        let result = priority.find((type) => types.includes(type));
        if (result) {
            return result;
        }
    }
    if ('type' in schema) {
        return schema.type;
    }
    if ('const' in schema) {
        return typeof schema.const;
    }
    return 'object';
}
export function flattenSchema(schema, base = {}, parent = '') {
    if (schema === undefined) {
        return base;
    }
    for (const [k, value] of Object.entries(schema)) {
        const key = parent ? `${parent}.${k}` : k;
        if (getSchemaType(value) === 'object') {
            if ('properties' in value) {
                flattenSchema(value.properties, base, key);
            }
            else {
                base[key] = value;
            }
        }
        else {
            base[key] = value;
        }
    }
    return base;
}
export function setNestedProperty(obj, path, value) {
    const keys = path.split('.');
    let current = obj;
    for (let i = 0; i < keys.length - 1; i++) {
        if (!current[keys[i]]) {
            current[keys[i]] = {};
        }
        current = current[keys[i]];
    }
    const finalKey = keys[keys.length - 1];
    Object.defineProperty(current, finalKey, {
        value: value,
        writable: true,
        enumerable: true,
        configurable: true,
    });
}
export function camelCaseToKebabCase(str) {
    return str.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
}
export function kebabCaseToCamelCase(str) {
    return str.replace(/-./g, (match) => match[1].toUpperCase());
}
