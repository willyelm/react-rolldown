import { LOG_LEVEL_DEBUG, LOG_LEVEL_INFO, LOG_LEVEL_WARN, LOG_LEVEL_ERROR, logLevelPriority, } from './logging';
import { error } from './logs';
import { normalizeLog } from './logHandler';
import path from 'node:path';
import { VERSION } from '..';
import { getSortedPlugins } from '../plugin/plugin-driver';
export function getLogger(plugins, onLog, logLevel) {
    const minimalPriority = logLevelPriority[logLevel];
    const logger = (level, log, skipped = new Set()) => {
        const logPriority = logLevelPriority[level];
        if (logPriority < minimalPriority) {
            return;
        }
        for (const plugin of getSortedPlugins('onLog', plugins)) {
            if (skipped.has(plugin))
                continue;
            const { onLog: pluginOnLog } = plugin;
            if (pluginOnLog) {
                const getLogHandler = (level) => {
                    if (logLevelPriority[level] < minimalPriority) {
                        return () => { };
                    }
                    return (log) => logger(level, normalizeLog(log), new Set(skipped).add(plugin));
                };
                const handler = 'handler' in pluginOnLog ? pluginOnLog.handler : pluginOnLog;
                if (handler.call({
                    debug: getLogHandler(LOG_LEVEL_DEBUG),
                    error: (log) => error(normalizeLog(log)),
                    info: getLogHandler(LOG_LEVEL_INFO),
                    meta: {
                        rollupVersion: '4.23.0',
                        rolldownVersion: VERSION,
                        watchMode: false,
                    },
                    warn: getLogHandler(LOG_LEVEL_WARN),
                    pluginName: plugin.name || 'unknown',
                }, level, log) === false) {
                    return;
                }
            }
        }
        onLog(level, log);
    };
    return logger;
}
export const getOnLog = (config, logLevel, printLog = defaultPrintLog) => {
    const { onwarn, onLog } = config;
    const defaultOnLog = getDefaultOnLog(printLog, onwarn);
    if (onLog) {
        const minimalPriority = logLevelPriority[logLevel];
        return (level, log) => onLog(level, addLogToString(log), (level, handledLog) => {
            if (level === LOG_LEVEL_ERROR) {
                return error(normalizeLog(handledLog));
            }
            if (logLevelPriority[level] >= minimalPriority) {
                defaultOnLog(level, normalizeLog(handledLog));
            }
        });
    }
    return defaultOnLog;
};
const getDefaultOnLog = (printLog, onwarn) => onwarn
    ? (level, log) => {
        if (level === LOG_LEVEL_WARN) {
            onwarn(addLogToString(log), (warning) => printLog(LOG_LEVEL_WARN, normalizeLog(warning)));
        }
        else {
            printLog(level, log);
        }
    }
    : printLog;
const addLogToString = (log) => {
    Object.defineProperty(log, 'toString', {
        value: () => getExtendedLogMessage(log),
        writable: true,
    });
    return log;
};
const defaultPrintLog = (level, log) => {
    const message = getExtendedLogMessage(log);
    switch (level) {
        case LOG_LEVEL_WARN: {
            return console.warn(message);
        }
        case LOG_LEVEL_DEBUG: {
            return console.debug(message);
        }
        default: {
            return console.info(message);
        }
    }
};
const getExtendedLogMessage = (log) => {
    let prefix = '';
    if (log.plugin) {
        prefix += `(${log.plugin} plugin) `;
    }
    if (log.loc) {
        prefix += `${relativeId(log.loc.file)} (${log.loc.line}:${log.loc.column}) `;
    }
    return prefix + log.message;
};
function relativeId(id) {
    if (!path.isAbsolute(id))
        return id;
    return path.relative(path.resolve(), id);
}
