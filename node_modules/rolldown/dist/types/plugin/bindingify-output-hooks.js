import { normalizeHook } from '../utils/normalize-hook';
import { collectChangedBundle, transformToOutputBundle, } from '../utils/transform-to-rollup-output';
import { PluginContext } from './plugin-context';
import { bindingifySourcemap } from '../types/sourcemap';
import { bindingifyPluginHookMeta, } from './bindingify-plugin-hook-meta';
import { NormalizedInputOptionsImpl } from '../options/normalized-input-options';
import { NormalizedOutputOptionsImpl } from '../options/normalized-output-options';
import { transformRenderedChunk } from '../utils/transform-rendered-chunk';
import { normalizeErrors } from '../utils/error';
export function bindingifyRenderStart(args) {
    const hook = args.plugin.renderStart;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, opts) => {
            handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), new NormalizedOutputOptionsImpl(opts), new NormalizedInputOptionsImpl(opts, args.onLog));
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyRenderChunk(args) {
    const hook = args.plugin.renderChunk;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, code, chunk, opts) => {
            const ret = await handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), code, transformRenderedChunk(chunk), new NormalizedOutputOptionsImpl(opts));
            if (ret == null) {
                return;
            }
            if (typeof ret === 'string') {
                return { code: ret };
            }
            if (!ret.map) {
                return { code: ret.code };
            }
            return {
                code: ret.code,
                map: bindingifySourcemap(ret.map),
            };
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyAugmentChunkHash(args) {
    const hook = args.plugin.augmentChunkHash;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, chunk) => {
            return await handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyRenderError(args) {
    const hook = args.plugin.renderError;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, err) => {
            handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), normalizeErrors(err));
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyGenerateBundle(args) {
    const hook = args.plugin.generateBundle;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, bundle, isWrite, opts) => {
            const changed = {
                updated: new Set(),
                deleted: new Set(),
            };
            const output = transformToOutputBundle(bundle, changed);
            await handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), new NormalizedOutputOptionsImpl(opts), output, isWrite);
            return collectChangedBundle(changed, output);
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyWriteBundle(args) {
    const hook = args.plugin.writeBundle;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, bundle, opts) => {
            const changed = {
                updated: new Set(),
                deleted: new Set(),
            };
            const output = transformToOutputBundle(bundle, changed);
            await handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), new NormalizedOutputOptionsImpl(opts), output);
            return collectChangedBundle(changed, output);
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyCloseBundle(args) {
    const hook = args.plugin.closeBundle;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx) => {
            await handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel));
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyBanner(args) {
    const hook = args.plugin.banner;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, chunk) => {
            if (typeof handler === 'string') {
                return handler;
            }
            return handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyFooter(args) {
    const hook = args.plugin.footer;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, chunk) => {
            if (typeof handler === 'string') {
                return handler;
            }
            return handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyIntro(args) {
    const hook = args.plugin.intro;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, chunk) => {
            if (typeof handler === 'string') {
                return handler;
            }
            return handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
export function bindingifyOutro(args) {
    const hook = args.plugin.outro;
    if (!hook) {
        return {};
    }
    const { handler, meta } = normalizeHook(hook);
    return {
        plugin: async (ctx, chunk) => {
            if (typeof handler === 'string') {
                return handler;
            }
            return handler.call(new PluginContext(args.outputOptions, ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
        },
        meta: bindingifyPluginHookMeta(meta),
    };
}
