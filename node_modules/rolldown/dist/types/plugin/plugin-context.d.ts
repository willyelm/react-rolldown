import type { BindingPluginContext } from '../binding';
import type { CustomPluginOptions, ModuleOptions, Plugin, ResolvedId } from './index';
import { MinimalPluginContext } from '../plugin/minimal-plugin-context';
import { AssetSource } from '../utils/asset-source';
import { ModuleInfo } from '../types/module-info';
import { PluginContextData } from './plugin-context-data';
import { SYMBOL_FOR_RESOLVE_CALLER_THAT_SKIP_SELF } from '../constants/plugin-context';
import { PartialNull } from '../types/utils';
import type { LogHandler, LogLevelOption } from '../types/misc';
import { OutputOptions } from '../options/output-options';
export interface EmittedAsset {
    type: 'asset';
    name?: string;
    fileName?: string;
    originalFileName?: string | null;
    source: AssetSource;
}
export interface EmittedChunk {
    type: 'chunk';
    name?: string;
    fileName?: string;
    id: string;
    importer?: string;
}
export type EmittedFile = EmittedAsset;
export interface PluginContextResolveOptions {
    skipSelf?: boolean;
    custom?: CustomPluginOptions;
}
export interface PrivatePluginContextResolveOptions extends PluginContextResolveOptions {
    [SYMBOL_FOR_RESOLVE_CALLER_THAT_SKIP_SELF]?: symbol;
}
export declare class PluginContext extends MinimalPluginContext {
    private outputOptions;
    private context;
    private data;
    private onLog;
    private currentLoadingModule?;
    constructor(outputOptions: OutputOptions, context: BindingPluginContext, plugin: Plugin, data: PluginContextData, onLog: LogHandler, logLevel: LogLevelOption, currentLoadingModule?: string | undefined);
    load(options: {
        id: string;
        resolveDependencies?: boolean;
    } & Partial<PartialNull<ModuleOptions>>): Promise<ModuleInfo>;
    resolve(source: string, importer?: string, options?: PluginContextResolveOptions): Promise<ResolvedId | null>;
    emitFile(file: EmittedAsset | EmittedChunk): string;
    private getAssetFileNames;
    getFileName(referenceId: string): string;
    getModuleInfo(id: string): ModuleInfo | null;
    getModuleIds(): IterableIterator<string>;
    addWatchFile(id: string): void;
    /**
     * @deprecated This rollup API won't be supported by rolldown. Using this API will cause runtime error.
     */
    parse(_input: string, _options?: any): any;
}
