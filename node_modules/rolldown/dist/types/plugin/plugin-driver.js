import { getLogHandler, normalizeLog } from '../log/logHandler';
import { LOG_LEVEL_DEBUG, LOG_LEVEL_INFO, LOG_LEVEL_WARN } from '../log/logging';
import { error, logPluginError } from '../log/logs';
import { normalizeHook } from '../utils/normalize-hook';
import { VERSION } from '..';
import { getLogger, getOnLog } from '../log/logger';
import { BuiltinPlugin } from '../builtin-plugin/constructors';
import { normalizePluginOption } from '../utils/normalize-plugin-option';
export class PluginDriver {
    static async callOptionsHook(inputOptions) {
        const logLevel = inputOptions.logLevel || LOG_LEVEL_INFO;
        const plugins = getSortedPlugins('options', getObjectPlugins(await normalizePluginOption(inputOptions.plugins)));
        const logger = getLogger(plugins, getOnLog(inputOptions, logLevel), logLevel);
        for (const plugin of plugins) {
            const name = plugin.name || 'unknown';
            const options = plugin.options;
            if (options) {
                const { handler } = normalizeHook(options);
                const result = await handler.call({
                    debug: getLogHandler(LOG_LEVEL_DEBUG, 'PLUGIN_LOG', logger, name, logLevel),
                    error: (e) => error(logPluginError(normalizeLog(e), name, { hook: 'onLog' })),
                    info: getLogHandler(LOG_LEVEL_INFO, 'PLUGIN_LOG', logger, name, logLevel),
                    meta: {
                        rollupVersion: '4.23.0',
                        rolldownVersion: VERSION,
                        watchMode: false,
                    },
                    warn: getLogHandler(LOG_LEVEL_WARN, 'PLUGIN_WARNING', logger, name, logLevel),
                    pluginName: name,
                }, inputOptions);
                if (result) {
                    inputOptions = result;
                }
            }
        }
        return inputOptions;
    }
    static callOutputOptionsHook(rawPlugins, outputOptions) {
        const sortedPlugins = getSortedPlugins('outputOptions', getObjectPlugins(rawPlugins));
        for (const plugin of sortedPlugins) {
            const options = plugin.outputOptions;
            if (options) {
                const { handler } = normalizeHook(options);
                const result = handler.call(null, outputOptions);
                if (result) {
                    outputOptions = result;
                }
            }
        }
        return outputOptions;
    }
}
export function getObjectPlugins(plugins) {
    return plugins.filter((plugin) => {
        if (!plugin) {
            return undefined;
        }
        if ('_parallel' in plugin) {
            return undefined;
        }
        if (plugin instanceof BuiltinPlugin) {
            return undefined;
        }
        return plugin;
    });
}
export function getSortedPlugins(hookName, plugins) {
    const pre = [];
    const normal = [];
    const post = [];
    for (const plugin of plugins) {
        const hook = plugin[hookName];
        if (hook) {
            if (typeof hook === 'object') {
                if (hook.order === 'pre') {
                    pre.push(plugin);
                    continue;
                }
                if (hook.order === 'post') {
                    post.push(plugin);
                    continue;
                }
            }
            normal.push(plugin);
        }
    }
    return [...pre, ...normal, ...post];
}
