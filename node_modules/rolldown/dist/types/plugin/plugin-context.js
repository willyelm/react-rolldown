import { MinimalPluginContext } from '../plugin/minimal-plugin-context';
import { bindingAssetSource } from '../utils/asset-source';
import { unimplemented, unsupported } from '../utils/misc';
import { SYMBOL_FOR_RESOLVE_CALLER_THAT_SKIP_SELF } from '../constants/plugin-context';
import { bindingifySideEffects } from '../utils/transform-side-effects';
import { LOG_LEVEL_WARN } from '../log/logging';
import { logCycleLoading } from '../log/logs';
export class PluginContext extends MinimalPluginContext {
    outputOptions;
    context;
    data;
    onLog;
    currentLoadingModule;
    constructor(outputOptions, context, plugin, data, onLog, logLevel, currentLoadingModule) {
        super(onLog, logLevel, plugin.name);
        this.outputOptions = outputOptions;
        this.context = context;
        this.data = data;
        this.onLog = onLog;
        this.currentLoadingModule = currentLoadingModule;
    }
    async load(options) {
        const id = options.id;
        if (id === this.currentLoadingModule) {
            this.onLog(LOG_LEVEL_WARN, logCycleLoading(this.pluginName, this.currentLoadingModule));
        }
        // resolveDependencies always true at rolldown
        const moduleInfo = this.data.getModuleInfo(id, this.context);
        if (moduleInfo && moduleInfo.code !== null /* module already parsed */) {
            return moduleInfo;
        }
        const rawOptions = {
            meta: options.meta || {},
            moduleSideEffects: options.moduleSideEffects || null,
        };
        this.data.updateModuleOption(id, rawOptions);
        async function createLoadModulePromise(context, data) {
            const loadPromise = data.loadModulePromiseMap.get(id);
            if (loadPromise) {
                return loadPromise;
            }
            let resolveFn;
            // TODO: If is not resolved, we need to set a time to avoid waiting.
            const promise = new Promise((resolve, _) => {
                resolveFn = resolve;
            });
            data.loadModulePromiseMap.set(id, promise);
            try {
                await context.load(id, bindingifySideEffects(options.moduleSideEffects), resolveFn);
            }
            finally {
                // If the load module has failed, avoid it re-load using unresolved promise.
                data.loadModulePromiseMap.delete(id);
            }
            return promise;
        }
        // Here using one promise to avoid pass more callback to rust side, it only accept one callback, other will be ignored.
        await createLoadModulePromise(this.context, this.data);
        return this.data.getModuleInfo(id, this.context);
    }
    async resolve(source, importer, options) {
        let receipt = undefined;
        if (options != null) {
            receipt = this.data.saveResolveOptions(options);
        }
        const res = await this.context.resolve(source, importer, {
            custom: receipt,
            skipSelf: options?.skipSelf,
        });
        if (receipt != null) {
            this.data.removeSavedResolveOptions(receipt);
        }
        if (res == null)
            return null;
        const info = this.data.getModuleOption(res.id) || {};
        return { ...res, ...info };
    }
    emitFile(file) {
        // @ts-expect-error
        if (file.type === 'prebuilt-chunk') {
            return unimplemented('PluginContext.emitFile with type prebuilt-chunk');
        }
        if (file.type === 'chunk') {
            return this.context.emitChunk(file);
        }
        const filename = file.fileName ? undefined : this.getAssetFileNames(file);
        return this.context.emitFile({
            ...file,
            originalFileName: file.originalFileName || undefined,
            source: bindingAssetSource(file.source),
        }, filename);
    }
    getAssetFileNames(file) {
        if (typeof this.outputOptions.assetFileNames === 'function') {
            return this.outputOptions.assetFileNames({
                names: file.name ? [file.name] : [],
                originalFileNames: file.originalFileName ? [file.originalFileName] : [],
                source: file.source,
                type: 'asset',
            });
        }
    }
    getFileName(referenceId) {
        return this.context.getFileName(referenceId);
    }
    getModuleInfo(id) {
        return this.data.getModuleInfo(id, this.context);
    }
    getModuleIds() {
        return this.data.getModuleIds(this.context);
    }
    addWatchFile(id) {
        this.context.addWatchFile(id);
    }
    /**
     * @deprecated This rollup API won't be supported by rolldown. Using this API will cause runtime error.
     */
    parse(_input, _options) {
        unsupported('`PluginContext#parse` is not supported by rolldown.');
    }
}
